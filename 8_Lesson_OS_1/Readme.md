## Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1) Вызов CD это chdir("/tmp"), выполняется почти в самом конце стектрейса.
2) Файл базы - /usr/share/misc/magic.mgc в логах он отображается как
`openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`
3) Чтоб не кодить программу, планировал сделать с nano, но nano не создает постоянный поток записи в файл, в losf не было данных.
Использовал vi, в нем при работе с файлом создается поток записи в файл.    
Сначала ищем PID процесса, далее через lsof -p PID определяем открыте файлы.  
`vi      8464 yolo    4u   REG                8,2    12288 14427056 /home/yolo/.file_to_delete.swp`  
Удаляем файл  
`rm -f .file_to_delete.swp`  
Проверяем что поменялось в lsof  
`vi      8464 yolo    4u   REG                8,2    12288 14427056 /home/yolo/.file_to_delete.swp (deleted)`  
Чистим место  
`echo "" >/proc/8464/fd/4` Расшифровка 8464-PID процесса VI, 4 - файлов дескриптор, который нашли в lsof  
Проверяем lsof  
`vi      8464 yolo    4u   REG                8,2        1 14427056 /home/yolo/.file_to_delete.swp (deleted)`
Место освободили, все сделано верно.
4) Зомби процесс при переходе в состоянии "зомби" освобождает свои ресурсы, но продолжают занимать пункт в таблице процессов.
5) При запуске от sudo(без него не запускает) на рабочем ноутбуке с Kubuntu получаю такой вывод.
```
PID    COMM               FD ERR PATH
3130   CrBrowserMain     145   0 /proc/meminfo
1583   ksysguardd         22   0 /etc/mtab
1583   ksysguardd         22   0 /etc/mtab
1583   ksysguardd         22   0 /proc/net/dev
1583   ksysguardd         22   0 /proc/net/wireless
1583   ksysguardd         22   0 /proc/cpuinfo
1583   ksysguardd         22   0 /sys/bus/cpu/devices/cpu0/cpufreq/scaling_cur_freq
```
6) В обычном man не нашел, залез в man разработчиков через команду `man 2 uname`, далее поиском через паттерн, нашел ответ  
`Part of the uname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.`
7) Команды написанные через `;` выполняются подряд в любом случае, кроме краша системы.
Команды написанные через `&&` выполняются с условием. Если команда слева завершилась корректно(успешно)то команда справа будет выполнена.
Опция `set -e` не заменяет логическую функцию &&, она может помочь при отладке скрипта, но не при выполнении логических операций.
Про это написано на 2770 строке в `man bash`.  
8) `-e` прерывает исполнения последовательности команд при ошибке любой команды кроме последней в цепочке.   
`-u` неустановленные или не заданные параметры и переменные считаются как ошибки, выведет текст ошибки и завершит программу при не интерактивном вызове.  
`-x` вывод лог/последовательность выполнения команд в скрипте.   
`-o pipefail` возвращает код возврата последней или наиболее правой команды при не успешном завершении, код отличный от 0 и 0 если все команды завершились корректно.  
Удобно использоваться при отладке скриптов т.к. это почти режим Debug'a, когда любая из ошибок новичка будет отловлена, + будет видно ветвление и ход выполнения команд.
9) Чаще всего встречаются статусы у процессов вида `S*(Ss, Sl, Ss+ и т.д.)` - процессы спящие, ожидающие события для выхода из сна.
И процессы вида `I* (I, I<)` - потоки("нити") ядра в режиме ожидания.
Второй символ послед заглавной буквы обозначает дополнительный статус процесса, многопоточность, приоритет, является ли процесс фоновым и т.д.